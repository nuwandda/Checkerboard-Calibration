import numpy as np
import cv2
import glob
import logging
from scipy.optimize import curve_fit
import util
import matplotlib.pyplot as plt
import pathlib


# termination criteria
criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)

def find_corners(square_size=0.025, width=9, height=6):
    """ Apply camera calibration operation for images in the given directory path. """
    # prepare object points, like (0,0,0), (1,0,0), (2,0,0) ....,(8,6,0)
    util.info("Finding checkerboard corners...")
    objp = np.zeros((height*width, 2), np.float32)
    objp[:, :2] = np.mgrid[0:width, 0:height].T.reshape(-1, 2)

    objp = objp * square_size

    # Arrays to store object points and image points from all the images.
    objpoints = []  # 3d point in real world space
    imgpoints = []  # 2d points in image plane.

    images = glob.glob('images/IMG*.jpg')
    count = 1
    for fname in images:
        util.info("Finding corners for " + fname)
        img = cv2.imread(fname)
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        # Find the chess board corners
        ret, corners = cv2.findChessboardCorners(gray, (width, height), None)

        # If found, add object points, image points (after refining them)
        if ret:
            objpoints.append(objp)

            corners2 = cv2.cornerSubPix(
                gray, corners, (11, 11), (-1, -1), criteria)
            imgpoints.append(corners2)

            # Draw and display the corners
            img = cv2.drawChessboardCorners(
                img, (width, height), corners2, ret)
            cv2.imwrite('images/pattern_' + str(count) + '.png', img)
            count += 1

    util.info("DONE.\n")
    return objpoints, imgpoints


def create_homography(image_points, world_points):
    util.info("Creating homography matrix...")
    a_list = []
    # Get similarity transformations
    t = util.get_transformation_matrix(image_points, 0)
    t_prime = util.get_transformation_matrix(world_points, 1)
    for i in range(len(image_points)):
        # In Zhang's calibration method, the world coordinate system is placed on the checkerboard plane,
        # and the checkerboard plane is set to the plane with z = 0.
        # First, convert each points into homogeneous coordinates
        point1 = util.to_homogeneous(image_points[i], 0)
        point2 = util.to_homogeneous(world_points[i], 1)
        # Get normalized points with the matrix calculated before
        normalized_point1 = np.dot(point1, t.T)
        normalized_point2 = np.dot(point2, t_prime.T)
        a, b = normalized_point1.item(0), normalized_point1.item(1)
        x, y = normalized_point2.item(0), normalized_point2.item(1)

        # Form the 2n x 12 matrix A by stacking the equations generated by each correspondence.
        a_row1 = [-x, -y, -1, 0, 0, 0, x * a, x * b, a]
        a_row2 = [0, 0, 0, -x, -y, -1, y * a, y * b, b]

        # Assemble the 2n x 9 matrices Ai into a single matrix A.
        a_list.append(a_row1)
        a_list.append(a_row2)

    a_matrix = np.matrix(a_list)

    # A solution of Ah = 0 is obtained from the right singular vector of V associated with the smallest singular value.
    U, S, V_t = np.linalg.svd(a_matrix)

    # The parameters are in the min line of Vh
    L = V_t[-1]
    H = L.reshape(3, 3)

    # Denormalization
    H = np.dot(np.dot(np.linalg.inv(t), H), t_prime)

    util.info("DONE.\n")
    return H


def cost_function(coordinates, *params):
    h11, h12, h13, h21, h22, h23, h31, h32, h33 = params

    N = coordinates.shape[0] // 2

    X = coordinates[:N]
    Y = coordinates[N:]

    x = (h11 * X + h12 * Y + h13) / (h31 * X + h32 * Y + h33)
    y = (h21 * X + h22 * Y + h23) / (h31 * X + h32 * Y + h33)

    result = np.zeros_like(coordinates)
    result[:N] = x
    result[N:] = y

    return result


def jacobian_function(coordinates, *params):
    # The  partial  derivatives  of  the  first  2  elements  of u and v  given  as  follows.
    # These  values  are  used  for computing the Jacobian used for LM optimization
    h11, h12, h13, h21, h22, h23, h31, h32, h33 = params

    N = coordinates.shape[0] // 2

    X = coordinates[:N]
    Y = coordinates[N:]

    J = np.zeros((N * 2, 9))
    J_x = J[:N]
    J_y = J[N:]

    s_x = h11 * X + h12 * Y + h13
    s_y = h21 * X + h22 * Y + h23
    w = h31 * X + h32 * Y + h33
    w_sq = w ** 2

    J_x[:, 0] = X / w
    J_x[:, 1] = Y / w
    J_x[:, 2] = 1. / w
    J_x[:, 6] = (-s_x * X) / w_sq
    J_x[:, 7] = (-s_x * Y) / w_sq
    J_x[:, 8] = -s_x / w_sq

    J_y[:, 3] = X / w
    J_y[:, 4] = Y / w
    J_y[:, 5] = 1. / w
    J_y[:, 6] = (-s_y * X) / w_sq
    J_y[:, 7] = (-s_y * Y) / w_sq
    J_y[:, 8] = -s_y / w_sq

    J[:N] = J_x
    J[N:] = J_y

    return J


def refine_homography(homography, image_coordinates, world_coordinates):
    util.info("Refining homography...")
    X, Y, x, y = image_coordinates[:, 0][:, 0], image_coordinates[:,
                                                                  0][:, 1], world_coordinates[:, 0], world_coordinates[:, 1]

    N = X.shape[0]

    h0 = homography.ravel()

    x_points = np.zeros(N * 2)
    x_points[:N] = X
    x_points[N:] = Y

    y_points = np.zeros(N * 2)
    y_points[:N] = x
    y_points[N:] = y

    # Use Levenberg-Marquardt to refine the linear homography estimate
    popt, pcov = curve_fit(cost_function, x_points,
                           y_points, p0=h0, jac=jacobian_function, maxfev=5000)
    h_refined = popt

    # Normalize and reconstitute homography
    h_refined /= h_refined[-1]
    H_refined = h_refined.reshape((3, 3))

    util.info("DONE.")
    return H_refined

def plot_differences(img_points, obj_points, homography, filename):
    util.info("Plotting difference of object points and projected points...")
    correspondences = util.get_correspondences(img_points, homography)

    x1 = obj_points[:, 0].tolist()
    y1 = obj_points[:, 1].tolist()

    plt.plot(x1, y1, label="Object Points")

    x2 = util.column(correspondences, 0)
    y2 = util.column(correspondences, 1)

    plt.plot(x2, y2, label="Projected Points")
    plt.xlabel('X Axis')

    plt.ylabel('Y Axis')

    plt.title('Comparison of object points and projected points')

    plt.legend()

    util.info("Writing graph...")
    plt.savefig("graphs/differences_" + filename + ".png")
    plt.clf()
    util.info("DONE.\n")


def create_vij(i, j, homography_list):
    util.info("Creating v" + str(i) + str(j) + "...")
    vij = np.zeros((homography_list.shape[0], 6))

    vij[:, 0] = homography_list[:, 0, i] * homography_list[:, 0, j]
    vij[:, 1] = homography_list[:, 0, i] * homography_list[:, 1, j] + homography_list[:, 1, i] * homography_list[:, 0, j]
    vij[:, 2] = homography_list[:, 1, i] * homography_list[:, 1, j]
    vij[:, 3] = homography_list[:, 2, i] * homography_list[:, 0, j] + homography_list[:, 0, i] * homography_list[:, 2, j]
    vij[:, 4] = homography_list[:, 2, i] * homography_list[:, 1, j] + homography_list[:, 1, i] * homography_list[:, 2, j]
    vij[:, 5] = homography_list[:, 2, i] * homography_list[:, 2, j]

    util.info("DONE.")
    return vij

def compute_intrinsics(homographies):
    util.info("Computing camera intrinsics...")
    # Stack homographies
    homography_list = np.zeros((len(homographies), 3, 3))
    for h, H in enumerate(homographies):
        homography_list[h] = H

    # Generate homogeneous equations
    v00 = create_vij(0, 0, homography_list)
    v01 = create_vij(0, 1, homography_list)
    v11 = create_vij(1, 1, homography_list)

    # Therefore, the two fundamental constraints, from a given homoghraphy, can be written ass 2 homogeneous equations in b.
    # V is a 2n x 6 matrix.
    v = np.zeros((2 * len(homographies), 6))
    v[:len(homographies)] = v01
    v[len(homographies):] = v00 - v11

    # The solution to the equation above is well known as the eigenvector of vTv associated with the smallest eigenvalue
    # (equivalently, the right singular vector of v associated with the smallest singular value).
    U, S, V_t = np.linalg.svd(v)

    b0, b1, b2, b3, b4, b5 = V_t[-1]

    # Once b is estimated, we can compute all camera instrinsic matrix A. You can check Appendix B (page 18) for the details.
    # Matrix B is estimated up to a scale factor.
    v0 = (b1 * b3 - b0 * b4) / (b0 * b2 - b1 * b1)
    lmbda = b5 - (b3 * b3 + v0 * (b1 * b3 - b0 * b4)) / b0
    alpha = np.sqrt(lmbda / b0)
    beta = np.sqrt(lmbda * b0 / (b0 * b2 - b1 * b1))
    gamma = -b1 * alpha * alpha * beta / lmbda
    u0 = gamma * v0 / beta - b3 * alpha * alpha / lmbda

    # Then, create the intrinsic matrix
    a_matrix = np.array([[alpha, gamma, u0],
                         [0.,  beta, v0],
                         [0.,    0., 1.]])

    util.info("DONE.\n")
    return a_matrix


def main():
    pathlib.Path('graphs/').mkdir(parents=True, exist_ok=True) 
    obj_points, img_points = find_corners()

    refined_homographies = []
    for index in range(len(img_points)):
        util.info("Image Count: " + str(index + 1))
        h = create_homography(img_points[index], obj_points[index])
        util.info("Homography:\n" + str(h) + "\n")
        h = refine_homography(h, img_points[index], obj_points[index])
        util.info("Refined Homography:\n" + str(h) + "\n")
        refined_homographies.append(h)
        plot_differences(img_points[index], obj_points[index], h, str(index + 1))
    
    k = compute_intrinsics(refined_homographies)
    util.info("Camera Intrinsics:\n" + str(k) + "\n")

if __name__ == "__main__":
    logging.basicConfig(format='%(asctime)s - %(message)s', level=logging.INFO)
    main()
